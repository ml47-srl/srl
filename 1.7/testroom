#!/usr/bin/python3 -B

from curses import *
from srlcore import *
import sys
import os

def die(errormsg=""):
	global screen
	if screen != None:
		endwin()
	debug(errormsg)
	sys.exit()

def setMsg(info):
	global msg
	debug("setMsg(" + info + ")")
	msg=info
	renderString(maxY()-1, 0, msg)

def clearScreen():
	global screen
	global msg
	screen.clear()
	renderString(maxY()-1, 0, msg)

# main

def renderString(line, x, s):
	global screen
	if x > maxX():
		print("renderString(): x{" + str(x) + "} > maxX(){" + str(maxX()) + "}")
	if line > maxY():
		print("renderString(): line{" + str(line) + "} > maxY(){" + str(maxY()) + "}")
	try:
		screen.addstr(line, x, s)
	except:
		die("failed to render:\nstring{" + s + "}\nline{" + str(line) + "}\nx{" + str(x) + "}\nmaxX(){" + str(maxX()) + "}\nmaxY(){" + str(maxY()) + "}")

def maxX():
	return screen.getmaxyx()[1]

def maxY():
	return screen.getmaxyx()[0]

def repaintHandleRule(rule, targetCellIndex):
	global scroll
	clearScreen()
	folding=0
	# render handled rule
	if targetCellIndex < 20:
		renderString(0, 20-targetCellIndex, rule.toString()[:targetCellIndex-20+maxX()])
	else:
		renderString(0, 0, rule.toString()[targetCellIndex-20:targetCellIndex-20+maxX()])
	# render targetCellIndex-marker
	renderString(1, 20, "^")

def findNextCellIndex(rule, pos):
	tmp = pos
	# bis zum nxten bedeutungsvollen Zeichen
	while rule[tmp] != "," and rule[tmp] != "(" and rule[tmp] != ")":
		tmp += 1
		if len(rule)-2 < tmp:
			return pos
	# bis zur nxten Cell
	while rule[tmp] == "," or rule[tmp] == "(" or rule[tmp] == ")" or rule[tmp] == " " or rule[tmp] == ".":
		tmp += 1
		if len(rule)-2 < tmp:
			return pos
	return tmp

def findPreviousCellIndex(rule, pos):
	if pos == 0:
		return pos
	tmp = pos-1
	# bis zum Ende der vorherigen Cell
	while rule[tmp] == "," or rule[tmp] == "(" or rule[tmp] == ")" or rule[tmp] == " ":
		tmp -= 1
	# bis zum Anfang der vorherigen Cell
	while rule[tmp-1] != "," and rule[tmp-1] != "(" and rule[tmp-1] != ")" and rule[tmp-1] != " " and tmp > 0:
		tmp -= 1
	return tmp

def handleRule(ruleID):
	rule = system.getRules()[ruleID]
	global scroll
	global running
	targetCellIndex=0
	while running:
		repaintHandleRule(rule, targetCellIndex)
		key = screen.getch()
		
		if str(key) == str(KEY_LEFT):
				targetCellIndex = findPreviousCellIndex(rule.toString(), targetCellIndex)
		elif str(key) == str(KEY_RIGHT):
				targetCellIndex = findNextCellIndex(rule.toString(), targetCellIndex)
		elif key == ord('q'):
			scroll = 0
			break
		elif key == ord('\n'):
			newkey="a"
			string=""
			while True:
				while newkey != ord("\n"):
					newkey=screen.getch()
					if str(newkey) == str(KEY_BACKSPACE):
						string = string[:len(string)-1]
					else:
						try:
							string += chr(newkey)
						except:
							setMsg("invalid key")
					renderString(2, 2, " "*(maxX()-2))
					renderString(2, 2, string)
				break
			system.applySubstitution(ruleID, spotToCspot(targetCellIndex, rule.toString()), string.strip())
			scroll = 0
			break
		else:
			setMsg("wrong key")

def repaintMain(targetRuleIndex):
	global scroll
	clearScreen()
	renderString(targetRuleIndex-scroll, 0, ">")
	folding=0
	for x in range(scroll, min(len(system.getRules()), maxY()-2+scroll)):
		if x == targetRuleIndex:
			renderString(x-scroll+folding, 2, system.getRules()[x].toString())
			folding = int(len(system.getRules()[x].toString())/(maxX()-2))
			if folding > 0:
				folding = folding+1
		else:
			if len(system.getRules()[x].toString()) > maxX()-2:
				renderString(x-scroll+folding, 2, system.getRules()[x].toString()[:maxX()-2-3] + "...")
			else:
				renderString(x-scroll+folding, 2, system.getRules()[x].toString()[:maxX()-2])

def main():
	global scroll
	global system
	global running
	targetRuleIndex=0
	while running:
		repaintMain(targetRuleIndex)
		key = screen.getch()

		if str(key) == str(KEY_DOWN):
			if targetRuleIndex < len(system.getRules())-1:
				targetRuleIndex += 1
				if targetRuleIndex > maxY()-scroll-3 and targetRuleIndex - scroll == maxY()-2:
					scroll += 1
		elif str(key) == str(KEY_UP):
			if targetRuleIndex > 0:
				targetRuleIndex -= 1
				if targetRuleIndex < scroll:
					scroll -= 1
		elif key == ord('q'):
			running=False
		elif key == ord('\n'):
			handleRule(targetRuleIndex)
		else:
			setMsg("wrong key")


def init():
	global system
	global running
	global screen
	global msg
	global scroll

	open("debug", "w").close() # clear Debugfile

	screen=None
	if len(sys.argv) != 2:
		die("Bad amount of arguments")
	system = SRLSystem()
	system.loadFromFile(sys.argv[1])

	# screen init
	screen = initscr()
	curs_set(0)
	screen.keypad(True)
	noecho()
	# 

	msg=""
	scroll=0
	running = True

if __name__ == "__main__":
	init()
	main()
	endwin()
