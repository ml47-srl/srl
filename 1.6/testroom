#!/usr/bin/env python

from curses import *
import sys
import re


# init
if len(sys.argv) != 2:
	print("Bad amount of arguments")
	sys.exit()
filename=sys.argv[1]
try:
	fh = open(filename)
except:
	print("Couldn't load " + filename)
	sys.exit()
lines=fh.readlines()
fh.close()

screen = initscr()
rules=list()
screen.keypad(True)
noecho()
msg=""
scroll=0
running = True
open("debug", "w").close() # clear Debugfile

def die(errormsg=""):
	global screen
	if screen != None:
		endwin()
	print(errormsg)
	sys.exit()

def setMsg(info):
	global msg
	f = open("debug", "a")
	f.write(info + "\n")
	f.close()
	msg=info

class Rule:
	def __init__(self, string):
		self.cell = Cell(string.strip("\n").strip("."))
	def getCell(self):
		return self.cell
	def toString(self):
		return self.cell.toString() + "."

class Cell:
	def __init__(self, arg):
		self.args=list()
		self.body=""
		self.set(arg)
	def set(self, string):
		self.args=list()
		self.body=""
		if isinstance(string, Cell):
			set(string.toString())
			return
		string = string.strip("\n")
		setMsg("str="+string)
		self.valid = True # TODO sometimes False
		if string.find("(") == -1:
			self.body=string
			return
		self.body = string[:string.find("(")]
		while string != self.body + "()":
			# getCellAt
			index = string.find("(")+1
			cellname = ""
			openparens = 0
			while True:
				if string[index] == "(":
					openparens += 1
				elif string[index] == ")":
					openparens -= 1
				cellname += string[index]
				index += 1
				if len(string) < index+1:
					argstr = cellname
					break
				elif openparens == 0 and (string[index] == "," or string[index] == ")" or string[index] == "."):
					argstr = cellname
					break
			# /getCellAt
			string = (string[:string.find("(")+1] + string[string.find("(")+1+len(argstr):]).replace("(,", "(")
			self.args.append(Cell(argstr))
	def setArg(self, argID, newArg):
		self.args[argID] = newArg
	def isRule(self):
		global rules
		for rule in rules:
			if rule.getCell().toString() == self.toString():
				return True
		return False
	def isAny(self):
		return self.body.startswith("?")
	def isSpecific(self):
		return self.body.startswith("!")
	def isConstant(self):
		return self.body.startswith("\"") and self.body.endswith("\"")
	def isNormal(self):
		return not (self.isConstant() or self.isSpecific() or self.isAny())
	def getArgs(self):
		return self.args
	def isStringEqualsCell(self):
		return self.isEqualsCell() and self.args[0].toString() == self.args[1].toString()
	def isWrongConstantEqualsCell(self):
		return self.isEqualsCell() and self.getArgs()[0].isConstant() and self.getArgs()[1].isConstant() and (self.getArgs()[0].toString() != self.getArgs()[1].toString())
	def isEqualsCell(self):
		return self.body == "equals" and len(self.args) == 2
	def stringPosToArgPos(self, pos): # TODO doesn't work
		spos = len(self.body)+1
		for i in range(len(self.args)):
			if spos == pos:
				return i
			spos += len(self.args[i].toString()) + 1
		die("stringPosToArgPos(" + self.toString() + ", " + str(pos) + ") doesn't return anything")
	def argPosToStringPos(self, pos):
		spos = len(self.body)+1
		for i in range(pos):
			spos += len(self.args[i].toString()) + 1
		return spos
	def getCellAt(self, spot):
		parens=0
		if spot == 0:
			return Cell(self.toString())
		return self.args[self.stringPosToArgPos(spot)]
	def getNormalCellSubstitutions(self):
		global rules
		subs=list()
		if (self.isStringEqualsCell() or self.isRule()) and self.toString() != "\"true\"":
			subs.append("\"true\"")
		if self.isWrongConstantEqualsCell() and self.toString() != "\"false\"":
			subs.append("\"false\"")
		for rule in rules:
			if rule.getCell().isEqualsCell():
				if rule.getCell().args[0].toString() == self.toString() and (not rule.getCell().args[1].toString() in subs) and rule.getCell().args[1].toString() != self.toString():
					subs.append(rule.getCell().args[1].toString())
				if rule.getCell().args[1].toString() == self.toString() and (not rule.getCell().args[0].toString() in subs) and rule.getCell().args[0].toString() != self.toString():
					subs.append(rule.getCell().args[0].toString())
		return subs
	def toString(self):
		if len(self.args) == 0:
			return self.body
		else:
			tmp = self.body + "("
			for arg in self.args:
				tmp += arg.toString() + ","
			tmp = tmp.strip(",") + ")"
			return tmp
	def getID(self):
		if not (self.isAny() or self.isSpecific()):
			die("getID() called even if self isn't any/specific")
		return int(self.body[1:])
	def getMaxID(self):
		if self.isAny() or self.isSpecific():
			return self.getID()
		tmp = 1
		for arg in self.args:
			tmp = max(tmp, arg.getMaxID())
		return tmp
	def normalizeID(self):
		self.asdfasd = "ok" # TODO remove
	def incrementID(self, by): 
		if self.isAny():
			self.body = "?" + str(self.getID() + by)
		elif self.isSpecific():
			self.body = "!" + str(self.getID() + by)
		elif self.isNormal():
			for arg in self.args:
				arg.incrementID(by)
	def replaceAll(self, what, by):
		by = Cell(by)
		by.incrementID(self.getMaxID())
		by = by.toString()
		self.replaceAllRecursively(what, by)
		self.normalizeID()
	def replaceAllRecursively(self, what, by):
		for i in range(len(self.args)):
			if self.args[i].toString() == what:
				self.setArg(i, Cell(by))
			else:
				self.args[i].replaceAllRecursively(what, by)
	def replaceAt(self, where, by):
			argpos = self.stringPosToArgPos(where)
			self.args[argpos] = Cell(by)
alllines=""
for line in lines:
	if line.find("#") != -1:
		line = line[0:line.find("#")]
	alllines += line.strip("\n").replace(" ", "").replace("\t", "")
rules.append(Rule("equals(?1,?1)."))
rules.append(Rule("\"true\"."))
while alllines.find(".") != -1:
	rules.append(Rule(alllines[:alllines.find(".")+1]))
	alllines = alllines[alllines.find(".")+1:]

# main

def renderString(line, x, s):
	global screen
	if x > maxX():
		print("renderString(): x{" + str(x) + "} > maxX(){" + str(maxX()) + "}")
	if line > maxY():
		print("renderString(): line{" + str(line) + "} > maxY(){" + str(maxY()) + "}")
	try:
		screen.addstr(line, x, s)
	except:
		die("failed to render:\nstring{" + s + "}\nline{" + str(line) + "}\nx{" + str(x) + "}\nmaxX(){" + str(maxX()) + "}\nmaxY(){" + str(maxY()) + "}")

def maxX():
	maxY, maxX = screen.getmaxyx()
	return maxX

def maxY():
	maxY, maxX = screen.getmaxyx()
	return maxY

def repaintHandleRule(rule, targetCellIndex, substitutions, targetSubstitutionIndex):
	global scroll
	screen.clear()
	folding=0
	# render handled rule
	if targetCellIndex < 20:
		renderString(0, 20-targetCellIndex, rule.toString()[:targetCellIndex-20+maxX()])
	else:
		renderString(0, 0, rule.toString()[targetCellIndex-20:targetCellIndex-20+maxX()])
	# render targetCellIndex-marker
	renderString(1, 20, "^")
	# if there are substitutions
	if len(substitutions) > 0:
		# render the targetSubstitutionIndex-marker
		renderString(targetSubstitutionIndex+2-scroll, 0, ">")
		# render all substitutions (x = index of substitutions)
			# leave <scroll> substitutions at the beginning out
			# the last substitution is:
				# the last possible substitution in substitutions
				# or the last renderable substitution
		for x in range(scroll, min(len(substitutions), maxY()-4+scroll)):
			# render substitution at x + 2(beginning-lines) - scroll(the more you scroll, the more the text goes up)
			if x == targetSubstitutionIndex:
				renderString(x+2-scroll, 2, substitutions[x])
				folding = int(len(substitutions[x])/(maxX()-2))
				if folding > 0:
					folding += 1
			else:
				if len(substitutions[x]) > maxX()-2:
					renderString(x+2-scroll+folding, 2, substitutions[x][:maxX()-2-3] + "...")
				else:
					renderString(x+2-scroll+folding, 2, substitutions[x][:maxX()-2])
	renderString(maxY()-1, 0, msg)

def findSubstitutions(cell, rule):
	global screen
	if cell.isNormal() or cell.isConstant():
		return cell.getNormalCellSubstitutions()
	elif cell.isAny():
		l=list()
		l.append("...")
		return l
	elif cell.isSpecific():
		return list()
	else:
		print("what?")

def findNextCellIndex(rule, pos):
	tmp = pos
	# bis zum nxten bedeutungsvollen Zeichen
	while rule[tmp] != "," and rule[tmp] != "(" and rule[tmp] != ")":
		tmp += 1
		if len(rule)-2 < tmp:
			return pos
	# bis zur nxten Cell
	while rule[tmp] == "," or rule[tmp] == "(" or rule[tmp] == ")" or rule[tmp] == " " or rule[tmp] == ".":
		tmp += 1
		if len(rule)-2 < tmp:
			return pos
	return tmp

def findPreviousCellIndex(rule, pos):
	if pos == 0:
		return pos
	tmp = pos-1
	# bis zum Ende der vorherigen Cell
	while rule[tmp] == "," or rule[tmp] == "(" or rule[tmp] == ")" or rule[tmp] == " ":
		tmp -= 1
	# bis zum Anfang der vorherigen Cell
	while rule[tmp-1] != "," and rule[tmp-1] != "(" and rule[tmp-1] != ")" and rule[tmp-1] != " " and tmp > 0:
		tmp -= 1
	return tmp

def handleRule(rule):
	global scroll
	global rules
	global running
	targetSubstitutionIndex=0
	targetCellIndex=0
	scroll = 0
	while running:
		substitutions=findSubstitutions(rule.getCell().getCellAt(targetCellIndex), rule)
		repaintHandleRule(rule, targetCellIndex, substitutions, targetSubstitutionIndex)
		key = screen.getch()
		
		if str(key) == str(KEY_DOWN):
			# if targetSubstitutionIndex is a valid index for substitutions (for targetSubstitutionIndex > -1)
			if targetSubstitutionIndex < len(substitutions)-1:
				targetSubstitutionIndex += 1
				# if targetSubstitutionIndex is under the list of substitutions
				if targetSubstitutionIndex >= maxY()-4-scroll and targetSubstitutionIndex+2-scroll == maxY()-2:
					scroll += 1
		elif str(key) == str(KEY_UP):
			if targetSubstitutionIndex > 0:
				targetSubstitutionIndex -= 1
				if targetSubstitutionIndex < scroll:
					scroll -= 1
		elif str(key) == str(KEY_LEFT):
				targetCellIndex = findPreviousCellIndex(rule.toString(), targetCellIndex)
				targetSubstitutionIndex = 0
				scroll = 0
		elif str(key) == str(KEY_RIGHT):
				targetCellIndex = findNextCellIndex(rule.toString(), targetCellIndex)
				targetSubstitutionIndex = 0
				scroll = 0
		elif key == ord('q'):
			scroll = 0
			break
		elif key == ord('\n'):
			if substitutions[targetSubstitutionIndex] == "...":
				newkey="a"
				string=""
				while True:
					while newkey != ord("\n"):
						newkey=screen.getch()
						string += chr(newkey)
						renderString(2, 2, string)
					c = Cell(string)
					if c.valid:
						substitutions[targetSubstitutionIndex] = string.strip("\n")
						break

			if len(substitutions) > 0:
				if rule.toString()[targetCellIndex] == "?" or rule.toString()[targetCellIndex] == "!":
					c = Cell(rule.getCell().toString())
					c.replaceAll(rule.getCell().getCellAt(targetCellIndex).toString(), substitutions[targetSubstitutionIndex])
					rules.append(Rule(c.toString() + "."))
				else:
					c = Cell(rule.getCell().toString())
					c.replaceAt(targetCellIndex, substitutions[targetSubstitutionIndex])
					rules.append(Rule(c.toString() + "."))
			scroll = 0
			break
		else:
			setMsg("wrong key")

def repaintMain(targetRuleIndex):
	global scroll
	global rules
	screen.clear()
	renderString(targetRuleIndex-scroll, 0, ">")
	folding=0
	for x in range(scroll, min(len(rules), maxY()-2+scroll)):
		if x == targetRuleIndex:
			renderString(x-scroll+folding, 2, rules[x].toString())
			folding = int(len(rules[x].toString())/(maxX()-2))
			if folding > 0:
				folding = folding+1
		else:
			if len(rules[x].toString()) > maxX()-2:
				renderString(x-scroll+folding, 2, rules[x].toString()[:maxX()-2-3] + "...")
			else:
				renderString(x-scroll+folding, 2, rules[x].toString()[:maxX()-2])
		renderString(maxY()-1, 0, msg)

def main():
	global scroll
	global rules
	global running
	targetRuleIndex=0
	while running:
		repaintMain(targetRuleIndex)
		key = screen.getch()

		if str(key) == str(KEY_DOWN):
			if targetRuleIndex < len(rules)-1:
				targetRuleIndex += 1
				if targetRuleIndex > maxY()-scroll-3 and targetRuleIndex - scroll == maxY()-2:
					scroll += 1
		elif str(key) == str(KEY_UP):
			if targetRuleIndex > 0:
				targetRuleIndex -= 1
				if targetRuleIndex < scroll:
					scroll -= 1
		elif key == ord('q'):
			running=False
		elif key == ord('\n'):
			handleRule(rules[targetRuleIndex])
		else:
			setMsg("wrong key")
if __name__ == "__main__":
	try:
		main()
	finally:
		endwin()
